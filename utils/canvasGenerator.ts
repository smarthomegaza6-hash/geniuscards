import { FlashcardData } from "../types";

export const generateCardImage = async (card: FlashcardData): Promise<string> => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  if (!ctx) return '';

  const width = 600;
  const height = 800;
  canvas.width = width;
  canvas.height = height;

  // Background Gradient
  const gradient = ctx.createLinearGradient(0, 0, width, height);
  gradient.addColorStop(0, '#667eea');
  gradient.addColorStop(1, '#764ba2');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);

  // Card Container (White with rounded corners)
  const x = 40, y = 40, w = 520, h = 720, r = 30;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fillStyle = 'white';
  ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
  ctx.shadowBlur = 30;
  ctx.shadowOffsetY = 20;
  ctx.fill();
  
  // Add Frame Border to canvas
  ctx.lineWidth = 4;
  ctx.strokeStyle = '#e0e7ff'; // Light Indigo
  ctx.stroke();

  // Add Inner Decorative Line
  ctx.beginPath();
  const ir = r - 5; // inner radius
  const gap = 12;
  const ix = x + gap, iy = y + gap, iw = w - gap*2, ih = h - gap*2;
  
  ctx.moveTo(ix + ir, iy);
  ctx.arcTo(ix + iw, iy, ix + iw, iy + ih, ir);
  ctx.arcTo(ix + iw, iy + ih, ix, iy + ih, ir);
  ctx.arcTo(ix, iy + ih, ix, iy, ir);
  ctx.arcTo(ix, iy, ix + iw, iy, ir);
  ctx.closePath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#c7d2fe'; // Slightly darker indigo
  ctx.stroke();

  ctx.shadowColor = "transparent"; // Reset shadow

  // Image or Emoji Handling
  const hasImage = !!card.imageUrl;
  
  if (hasImage && card.imageUrl) {
    try {
        const img = new Image();
        img.src = card.imageUrl;
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
        });

        // Draw image in the top half of the card
        const imgHeight = 320;
        
        ctx.save();
        // Create clipping path for top rounded corners
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + imgHeight);
        ctx.lineTo(x, y + imgHeight);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        ctx.clip();

        // Draw image centered and covering
        const scale = Math.max(w / img.width, imgHeight / img.height);
        const xPos = x + (w - img.width * scale) / 2;
        const yPos = y + (imgHeight - img.height * scale) / 2;
        ctx.drawImage(img, xPos, yPos, img.width * scale, img.height * scale);

        ctx.restore();
    } catch (e) {
        console.error("Failed to draw image on canvas", e);
        // Fallback to emoji
        drawEmoji(ctx, card.emoji, width);
    }
  } else {
    drawEmoji(ctx, card.emoji, width);
  }

  // Adjust text position based on image presence
  const textStartY = hasImage ? 400 : 300;

  // English Word
  ctx.fillStyle = '#667eea';
  ctx.font = 'bold 56px Poppins, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(card.en, width / 2, textStartY);

  // Part of Speech & Phonetic
  ctx.fillStyle = '#9ca3af';
  ctx.font = 'italic 24px Poppins, sans-serif';
  let metaText = card.phonetic;
  if (card.partOfSpeech) {
    metaText = `${card.partOfSpeech} â€¢ ${card.phonetic}`;
  }
  ctx.fillText(metaText, width / 2, textStartY + 45);

  // Arabic Translation
  ctx.fillStyle = '#1f2937';
  ctx.font = 'bold 48px Cairo, sans-serif';
  ctx.fillText(card.ar, width / 2, textStartY + 130);

  // Divider Line
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(100, textStartY + 170);
  ctx.lineTo(500, textStartY + 170);
  ctx.stroke();

  // Example Label
  ctx.fillStyle = '#667eea';
  ctx.font = 'bold 24px Poppins, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('ðŸ’¡ Example:', 80, textStartY + 220);

  // Example Text (Wrapped)
  ctx.fillStyle = '#4b5563';
  ctx.font = '24px Poppins, sans-serif';
  wrapText(ctx, card.example, 80, textStartY + 260, 440, 36);

  // Footer / Branding
  ctx.fillStyle = '#9ca3af';
  ctx.font = '16px Cairo, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Generated by Flashcard Genius AI', width / 2, 750);

  return canvas.toDataURL('image/png');
};

function drawEmoji(ctx: CanvasRenderingContext2D, emoji: string, width: number) {
    ctx.font = '120px "Segoe UI Emoji", "Apple Color Emoji"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, width / 2, 200);
}

// Helper for text wrapping
const wrapText = (ctx: CanvasRenderingContext2D, text: string, x: number, y: number, maxWidth: number, lineHeight: number) => {
  const words = text.split(' ');
  let line = '';

  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      ctx.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, y);
};